# Базовые понимания о разработке системы

+ Особенности голосования
  + Никакого блокчейна, считаем его "overengineering"
  + Частичное шгомоморфное шифрование бюллетени (Система Пайе) с подсчетом результатов только в процессе "Подсчета голосов"
      + Как делать переголосование?
        + После отправки бюллетеня придется оставлять на клиентской стороне какой-то остаток или слепок бюллетени, чтобы был вариант ZKP на наличие бюллетеня от этого пользователя
        + "Публикация тега "убитой бюллетени"
  + Слепые подписи Регистратором уже сгенерированной бюллетени
  + ZKP для подтверждения соответствия бюллетени ОДНОЙ ИЗ вариаций бюллетени
    + Схема Fiat-Shamir
      + Генерируем подтверждение формата бюллетени, а для остальных вариаций генерируем "фиктивные доказательства"
      + Проверяющий (Счетчик и Регистратор) проверяют доказательство форматом OR
  + Проверка того, что голоса учтены в процессе голосования
    + Система постоянно будет генерировать Merklie-дерево на основе всех активных бюллетеней и отдавать получаемый хеш корня дерева в открытом виде.
    + Каждый сможет скачать пулл зашифрованных бюллетеней и вычислить Merkile-дерево самостоятельно, сверившись с данными корня
      + А также найти данные своей бюллетени внутри дерева
    + Вычисление результатов голосования будет происходить не по базе данных бюллетеней, а по данным в Merklie-дереве
      + И как это подтвердить?
        + Публикуем Merklie-дерево
        + Вычисляем зашифрованную сумму
          + Механизм вычисления делать на основе Merklie-дерева
        + Публикуем зашифрованную сумму
        + Публикуем результат вычислений
        + Предполагается использование ZKP на подтверждение правильного вычисления



+ Компоненты системы
	+ Аутентификатор
    	+ Получает от администраторов голосования список пользователей в формате "Имя - Фамилия - Отчество"
        	+ Это простейший формат подтверждения личности,но это будет "пока"
      	+ Отдает пользователям токены доступа (JWT?) и данные Регистратора для генерации бюллетени и всех подтверждений, если пользователь подтвердил свою личность (пока просто вписал свои имя-фамилия-отчество)
        	+ Данные криптосхемы Пайе
        	+ Размер окна опции варианта и количество вариантов
        	+ Ключи для генерации слепой подписи
        	+ Правила генерации ZKP
	+ Регистратор
		+ Получает бюллетень пользователя
			+ Сверяет идентификатор со списокм
			+ Проверяет валидность ZKP
			+ Если всё хорошо, слепо подписывает бюллетень и отдает подпись пользователю
	+ Счетчик
		+ Получает бюллетень от пользователя с ZKP, гомоморфным шифрованием и *слепой подписью* от Регистратора
		+ Публикует все получаемые теги и зашифрованные бюллетени в открытом реестре
  		+ Обновляет Меркли-дерево и перепубликует корень
  		+ По окончании процесса получения бюллетеней - собирает данные из Меркли-дерева и полноценно высчитывает результаты, применяя закрытый ключ
    		+ А затем публикует результаты голосования и итоговую зашифрованную сумму


+ Описание инструментов
	+ Используемый фреймворк - Drogon C++
	+ Базы данных
		+ PG для хранения полученных данных и списка избирателей
		+ Redis для хранения токенов доступа пользователей
		+ Нужно поискать метод хранения дерева Меркли так, чтобы его было удобно генерировать из БД
    		+ Такой БД не найдено, отдыхаем
    		+ Вместо этого реализую кастомный класс для управления Merklie-деревом
        		+ Можно добавить очередную бюллетень
        		+ Можно удаить бюллетень по хешу бюллетени
        		+ Можно сгенерировать доказательство наличия бюллетени в хеше
            		+ Доказательство - набор частей дерева хешей, достаточный для перевычисления значения в корне


+ Какие страницы нужны
  + Страница входа 
    + Ввод "логина" и "пароля"
    + Должна вернуть токен доступа пользователю, после чего перекинет его в личный кабинет
      + Токен доступа нужно сохранить в Redis как временно активный, и, если что через время восстанавливать (по схеме с JWT)
  + Личный кабинет
    + Пишет, под каким аккаунтом произведен вход
    + С данных пользователя получает информацию о том, голосовал человек или нет, а также показывает хэш сгенерированных бюллетеней после голосования. Бюллетени должны храниться внутри клиеннта в сессии/cookie
  + Активные голосования
    + Сюда можно получить доступ из личного кабинета
    + Показывает список активных голосований и возможность проголосовать 
  + Страница голосования
    + Вместе с ней должны передаться части криптографии для гомоморфного шифрования и слепых подписей
    + Выводится вопрос голосования и варианты ответа
    + Под капотом генерируются нужные данные и отправляются в соответствии с протоколом голосования при нажатии "проголосовать" после выбора чекбокса/радиобаттона. 
    + Если голос уже передан, есть возможность переголосовать - так же откроется страница голосования
  + Страница реестров
    + Туда выводятся:
      + Реестр Меркли-дерева + Корень
  + Страница проверки учета голосов
    + Проверка осуществляется через Мerklie-дерево
  + Страница публикации результатов голосования




  Ситуация с WASM
  + Да, основу можно сделать с помощью WASM, но делать её я не буду, т.к. мне нужны полноценные криптобиблиотеки на стороне клиента для этой задачи
  + Вместо этого пока что перепишу часть фукнционала криптографии на JS




+ Следующие точки
  + ~~Подключить Postgres + Redis в докерах к Drogon~~
  + Сгенерить страницы 
  + Добавить в них код на JS из include-ов
  + 

