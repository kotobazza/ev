# Базовые понимания о разработке системы

## Угрозы протоколу
- Голосующий
	- Покупка голоса или внешнее принуждение
- Регистратор
	- Выдача бюллетеня для другого голосующего
	- Генерация бюллетеней со своей стороны напрямую к счетчику (сговор Регистратор-Счетчик)
	- Запрет выдачи бюллетеня при наличии в списках
- Счетчик
	- Мертвые души
	- Подделывание бюллетеней
	- Неучтение бюллетеня в результата
	- Перехват бюллетеня голосующего


- Голосующий
	- Покупка голоса или внешнее принуждение
		- : *Решается через возможность переголосовать*
		- : Другое решение - сделать:
			- Покупку голосов - наказуемой
				- Даже привлечение людей к голосованию с помощью лотереи является формой покупки голосов (если делается от имени партии)
			- Передачу своих линчых данных для аутентификации - небезопасной
- Регистратор
	- Выдача бюллетеня для другого голосующего
		- : Бюллетень не закрепляется за определенным именем. Вместо этого нужно максимальным образом предотвратить попытки взять бюллетень, имея учетные данные другого пользователя. *Эта задача связана с процессом аутентификации пользователей, и я не могу на это повлиять  не имея полноценного аутентификатора с ПД.*
			- **Не моя цель**
	- Генерация бюллетеней со своей стороны напрямую к счетчику (сговор Регистратор-Счетчик)
		- : Отделение процесса аутентификации от процесса подписи бюллетеня регистратором должно помочь. 
		- : Другой вариант - публикация обезличенных данных пользователей (хэши) вместе с действующими токенами
	- Запрет выдачи бюллетеня при наличии в списках
		- : Относится только к процессу аутентификации. **Тоже не моя проблема**
- Счетчик
	- Мертвые души
		+ : 
	- Подделывание бюллетеней
		- : *Все бюллетени шифруются и публикуются, в качестве доказательства их целостности используется дерево Меркла*
	- Неучтение бюллетеня в результата
		- : *Каждый может провести вычисление гомоморфной суммы на основе шифрованных бюллетеней*
	- Перехват бюллетеня голосующего
		- : *Хеш бюллетеня будет оставаться у пользователя для проверки наличия бюллетеня в списке в неизменном виде*
			- Фактически, до внесения хэша в дерево Меркла. Сделали проверку - можно уходить со страницы


### Обновление 1
+ Аутентификатор по итогу полностью забирает задачи Регистратора. 
	+ Очень важно понимать, что регистрация бюллетеня (именно что проверка ZKP бюллетеня и подпись ключом Регистратора) должна быть отделена от регистрации Пользователя. 
	+ Однако само по себе наличие Аутентификатора не решает проблем аутентификации
		+ Как избавиться от покупки голосов
		+ Как избавиться от "голосовать за другого"
		+ Как избавиться от токена голосования, выданного на имя другого человека

### Обновление 2
+ Была попытка использовать хэширование данных избирателей в качестве публичных идентификаторов
	+ Не прокатила - маме идея не понравилась, и мне теперь она тоже не нравится


## Особенности голосования
+ Никакого блокчейна, считаем его "overengineering"
+ Частичное шгомоморфное шифрование бюллетени (Система Пайе) с подсчетом результатов только в процессе "Подсчета голосов"
    + Как делать переголосование?
      + После отправки бюллетеня придется оставлять на клиентской стороне какой-то остаток или слепок бюллетени, чтобы был вариант ZKP на наличие бюллетеня от этого пользователя
      + "Публикация тега "убитой бюллетени"
+ Слепые подписи Регистратором уже сгенерированной бюллетени
+ ZKP для подтверждения соответствия бюллетени ОДНОЙ ИЗ вариаций бюллетени
  + Схема Fiat-Shamir
    + Генерируем подтверждение формата бюллетени, а для остальных вариаций генерируем "фиктивные доказательства"
    + Проверяющий (Счетчик и Регистратор) проверяют доказательство форматом OR
+ Проверка того, что голоса учтены в процессе голосования
  + Система постоянно будет генерировать Merklie-дерево на основе всех активных бюллетеней и отдавать получаемый хеш корня дерева в открытом виде.
  + Каждый сможет скачать пулл зашифрованных бюллетеней и вычислить Merkile-дерево самостоятельно, сверившись с данными корня
    + А также найти данные своей бюллетени внутри дерева
  + Вычисление результатов голосования будет происходить не по базе данных бюллетеней, а по данным в Merklie-дереве
    + И как это подтвердить?
      + Публикуем Merklie-дерево
      + Вычисляем зашифрованную сумму
        + Механизм вычисления делать на основе Merklie-дерева
      + Публикуем зашифрованную сумму
      + Публикуем результат вычислений
      + Предполагается использование ZKP на подтверждение правильного вычисления

## Процесс голосования
+ Предподготовка
  + Аутентификатор получает извне списки голосующих и их секреты для подвтерждения личности
  + Для регистратора и счетчика происходит генерация параметров гомоморфной схемы (публичный и приватный ключи) и параметров схемы шифрования 
+ Аутентификация
  + Голосующий обращается к аутентификатору
    + Передает ему свои идентификационные и аутентификационные данные
  + Аутентификатор проверяет соответствие идентификационных данных спискам и проверяет аутентификационные данные
    + Если все хорошо - выдает токен доступа JWT
    + Если нет, повторяет процесс аутентификации
+ Генерация бюллетени
  + В своем личном кабинете пользовател выбирает голосование для участия
    + Регистратор высылает открыте параметры криптосистем и форматы бюллетеней (вместе с вопросом и вариантами ответов)
  + Пользователь делает выбор
    + Клиентская часть 
      + Генерирует формат голоса
      + Производит гомоморфное шифрование и генерирует ZKP 
      + Ослепляет бюллетень
      + Шифрует все передаваемые параметры (и бюллетень) вместе с идентификаторо пользователя в системе и отправляет ее регистратору 
+ Подпись бюллетени
  + Регистратор получает параметры голосования от пользователя
  + Регистратор дешифрует параметры голосования, получая идентификатор пользователя, зашифрованную и ослепленную бюллетень и ее ZKP
  + Регистратор проверяет ZKP бюллетени
    + Если все хорошо - подписывает ослепленную бюллетень
    + Если нет - отменяет подпись бюллетени
  + Регистратор отсылает подпись бюллетени голосующему
  + Голосующий снимает ослепление
+ Передача бюллетени в счетчик
  + Голосующий генерирует на своей стороне хеш бюллетени для подтверждения знания о бюллетени
  + Голосующий шифрует подпись бюллетени и ZKP еще раз, после чего отправляет бюллетень в Счетчик
  + Счетчик расшифровывает полученные параметры
  + Счетчик проверяет подпись и ZKP бюллетени 
    + Если все хорошо - добавляет бюллетень в реестр зашифрованных бюллетеней и в Merklie-дерево
    + Если нет - отклоняет процесс добавления
+ Ситуация: проверка учета голоса до завершения процесса голосования
  + Голосующий отправляет хэш своей бюллетени Счетчику
  + Счетчик генерирует ZKP принадлежности хэша к Merklie-дереву
  + Голосующий на своей стороне проверяет ZKP
+ Подсчет голосов
  + Счетчик берет все бюллетени из Merklie-дерева
  + Счетчик суммирует все бюллетени Merklie-дерева
  + Счетчик применяет приватный ключ гомоморфного шифрования для получения результиующей суммы голосов
  + Счетчик публикует зашифрованную и расшифрованную суммы, и ZKP причастности результата к сумме
+ Проверка учета после подсчета голосов
  + Пользователь берет всё Merklie-дерево, реестр бюллетеней, его корень и зашифрованную сумму
  + Проверяет наличие хэша своей бюллетени в
    + Реестре
    + Дереве
    + Соответствие совего дерева и корня от Счетчика
  + Считает по всему реестру итоговую заширофванную сумму и сверяет ее с суммой от Счетчика
  + Проверяет ZKP причастности результата голосования к сумме 


## Компоненты архитектуры
+ Аутентификатор
  	+ Получает от администраторов голосования список пользователей в формате "Имя - Фамилия - Отчество"
      	+ Это простейший формат подтверждения личности,но это будет "пока"
    	+ Отдает пользователям токены доступа (JWT?) и данные Регистратора для генерации бюллетени и всех подтверждений, если пользователь подтвердил свою личность (пока просто вписал свои имя-фамилия-отчество)
      	+ Данные криптосхемы Пайе
      	+ Размер окна опции варианта и количество вариантов
      	+ Ключи для генерации слепой подписи
      	+ Правила генерации ZKP
+ Регистратор
+ Получает бюллетень пользователя
	+ Сверяет идентификатор со списокм
	+ Проверяет валидность ZKP
	+ Если всё хорошо, слепо подписывает бюллетень и отдает подпись пользователю
+ Счетчик
+ Получает бюллетень от пользователя с ZKP, гомоморфным шифрованием и *слепой подписью* от Регистратора
+ Публикует все получаемые теги и зашифрованные бюллетени в открытом реестре
		+ Обновляет Меркли-дерево и перепубликует корень
		+ По окончании процесса получения бюллетеней - собирает данные из Меркли-дерева и полноценно высчитывает результаты, применяя закрытый ключ
  		+ А затем публикует результаты голосования и итоговую зашифрованную сумму


## Описание инструментов
+ Используемый фреймворк - Drogon C++
+ Базы данных
+ PG для хранения полученных данных и списка избирателей
+ Redis для хранения токенов доступа пользователей
+ Нужно поискать метод хранения дерева Меркли так, чтобы его было удобно генерировать из БД
  		+ Такой БД не найдено, отдыхаем
  		+ Вместо этого реализую кастомный класс для управления Merklie-деревом
      		+ Можно добавить очередную бюллетень
      		+ Можно удаить бюллетень по хешу бюллетени
      		+ Можно сгенерировать доказательство наличия бюллетени в хеше
          		+ Доказательство - набор частей дерева хешей, достаточный для перевычисления значения в корне. Код уже реализован.








+ Какие страницы нужны
  + Страница входа 
    + Ввод "логина" и "пароля"
    + Должна вернуть токен доступа пользователю, после чего перекинет его в личный кабинет
      + Токен доступа нужно сохранить в Redis как временно активный, и, если что через время восстанавливать при предоставлении идентификационных данных (по схеме с JWT)
  + Личный кабинет
    + Пишет, под каким аккаунтом произведен вход
    + С данных пользователя получает информацию о том, голосовал человек или нет, а также показывает хэш сгенерированных бюллетеней после голосования. Бюллетени должны храниться внутри клиеннта в сессии/cookie
  + Активные голосования
    + Сюда можно получить доступ из личного кабинета
    + Показывает список активных голосований и возможность проголосовать 
  + Страница голосования
    + Вместе с ней должны передаться части криптографии для гомоморфного шифрования и слепых подписей
    + Выводится вопрос голосования и варианты ответа
    + Под капотом генерируются нужные данные и отправляются в соответствии с протоколом голосования при нажатии "проголосовать" после выбора чекбокса/радиобаттона. 
    + Если голос уже передан, есть возможность переголосовать - так же откроется страница голосования
  + Страница реестров
    + Туда выводятся:
      + Реестр Меркли-дерева + Корень
  + Страница проверки учета голосов
    + Проверка осуществляется через Мerklie-дерево
  + Страница публикации результатов голосования




  Ситуация с WASM
  + Да, основу можно сделать с помощью WASM, но делать её я не буду, т.к. мне нужны полноценные криптобиблиотеки на стороне клиента для этой задачи
  + Вместо этого пока что перепишу часть фукнционала криптографии на JS




+ Следующие точки
  + ~~Подключить Postgres + Redis в докерах к Drogon~~
  + Сгенерить страницы 
  + Добавить в них код на JS из include-ов


ОШИБКА В computeDigest на сервере и клиенте






