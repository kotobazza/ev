# Базовые понимания о разработке системы

+ Особенности голосования
  + Никакого блокчейна, считаем его "overengineering"
  + Частичное шгомоморфное шифрование бюллетени с подсчетом результатов только в процессе "Подсчета голосов"
    + Возможно ли с помощью гомоморфного шифрования делать что-то вроде экзит-пулов голосования в процессе голосования?
      + *Да, схемы PHE позволяют делать экзит-пулы.* Можно автоматизировать формат экзит-пулов и рассекречивать процентное соотношение голосов для N% бюллетеней. 
        + *Проблема:* постоянное использование ключа дешифровки, который запрещено использовать до процесса "Подсчета голосов"
      + Как делать переголосование?
        + После отправки бюллетеня придется оставлять на клиентской стороне какой-то остаток или слепок бюллетени, чтобы был вариант ZKP на наличие бюллетеня от этого пользователя
        + "Публикация тега убитой бюллетени"
  + Слепые подписи Регистратором уже сгенерированной бюллетени
  + ZKP для подтверждения соответствия бюллетени ОДНОЙ ИЗ вариаций бюллетени
    + Схема Fiat-Shamir
      + Генерируем подтверждение формата бюллетени, а для остальных вариаций генерируем "фиктивные доказательства"
      + Проверяющий (Счетчик и Регистратор) проверяют доказательство форматом OR
  + Проверка того, что голоса учтены в процессе голосования
    + Система постоянно будет генерировать Merklie-дерево на основе всех активных бюллетеней и отдавать получаемый хеш корня дерева в открытом виде.
    + Каждый сможет скачать пулл зашифрованных бюллетеней и вычислить Merkile-дерево самостоятельно, сверившись с данными корня
      + А также найти данные своей бюллетени внутри дерева
    + Вычисление результатов голосования будет происходить не по базе данных бюллетеней, а по данным в Merklie-дереве
      + **И как это подтвердить?**




+ Компоненты системы
	+ Аутентификатор
    	+ Получает от администраторов голосования список пользователей в формате "Имя - Фамилия - Отчество"
        	+ Это простейший формат, но это будет "пока"
      	+ Отдает пользователям токены доступа и данные Регистратора для генерации бюллетени и всех подтверждений
	+ Регистратор
		+ Получает бюллетень пользователя
			+ Сверяет идентификатор со списокм
			+ Проверяет валидность ZKP
			+ Если всё хорошо, слепо подписывает бюллетень
	+ Счетчик
		+ Получает бюллетень от пользователя с ZKP, гомоморфным шифрованием и *слепой подписью* от Регистратора
		+ Публикует все получаемые теги и зашифрованные бюллетени в открытом реестре
  		+ Обновляет Меркли-дерево и перепубликует корень
  		+ По окончании процесса получения бюллетеней - собирает данные из Меркли-дерева и полноценно высчитывает результаты, применяя закрытый ключ
    		+ А затем публикует результаты голосования и итоговую зашифрованную сумму


+ Описание инструментов
	+ Используемый фреймворк - Drogon C++
	+ Базы данных
		+ PG для хранения полученных данных и списка избирателей
		+ Redis для хранения токенов доступа пользователей
		+ **Нужно поискать метод хранения дерева Меркли так, чтобы его было удобно генерировать из БД**
