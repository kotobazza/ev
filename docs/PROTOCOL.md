## Угрозы протоколу
- Голосующий
	- Покупка голоса или внешнее принуждение
- Регистратор
	- Выдача бюллетеня для другого голосующего
	- Генерация бюллетеней со своей стороны напрямую к счетчику (сговор Регистратор-Счетчик)
	- Запрет выдачи бюллетеня при наличии в списках
- Счетчик
	- Мертвые души
	- Подделывание бюллетеней
	- Неучтение бюллетеня в результата
	- Перехват бюллетеня голосующего


- Голосующий
	- Покупка голоса или внешнее принуждение
		- : *Решается через возможность переголосовать*
		- : Другое решение - сделать:
			- Покупку голосов - наказуемой
				- Даже привлечение людей к голосованию с помощью лотереи является формой покупки голосов (если делается от имени партии)
			- Передачу своих линчых данных для аутентификации - небезопасной
- Регистратор
	- Выдача бюллетеня для другого голосующего
		- : Бюллетень не закрепляется за определенным именем. Вместо этого нужно максимальным образом предотвратить попытки взять бюллетень, имея учетные данные другого пользователя. *Эта задача связана с процессом аутентификации пользователей, и я не могу на это повлиять  не имея полноценного аутентификатора с ПД.*
			- **Не моя цель**
	- Генерация бюллетеней со своей стороны напрямую к счетчику (сговор Регистратор-Счетчик)
		- : Отделение процесса аутентификации от процесса подписи бюллетеня регистратором должно помочь. 
		- : Другой вариант - публикация обезличенных данных пользователей (хэши) вместе с действующими токенами
	- Запрет выдачи бюллетеня при наличии в списках
		- : Относится только к процессу аутентификации. **Тоже не моя проблема**
- Счетчик
	- Мертвые души
		+ : 
	- Подделывание бюллетеней
		- : *Все бюллетени шифруются и публикуются, в качестве доказательства их целостности используется дерево Меркла*
	- Неучтение бюллетеня в результата
		- : *Каждый может провести вычисление гомоморфной суммы на основе шифрованных бюллетеней*
	- Перехват бюллетеня голосующего
		- : *Хеш бюллетеня будет оставаться у пользователя для проверки наличия бюллетеня в списке в неизменном виде*
			- Фактически, до внесения хэша в дерево Меркла. Сделали проверку - можно уходить со страницы


### Обновление 1
+ Аутентификатор по итогу полностью забирает задачи Регистратора. 
	+ Очень важно понимать, что регистрация бюллетеня (именно что проверка ZKP бюллетеня и подпись ключом Регистратора) должна быть отделена от регистрации Пользователя. 
	+ Однако само по себе наличие Аутентификатора не решает проблем аутентификации
		+ Как избавиться от покупки голосов
		+ Как избавиться от "голосовать за другого"
		+ Как избавиться от токена голосования, выданного на имя другого человека

### Обновление 2
+ Была попытка использовать хэширование данных избирателей в качестве публичных идентификаторов
	+ Не прокатила - маме идея не понравилась, и мне теперь она тоже не нравится

## Описание протокола

+ Участники
	+ Изибиратель
	+ Регистратор
	+ Счетчик
	+ *(возможно существующий Аутентификатор)*


+ Процесс голосования
	1. Регистрация избирателя
		- Избиратель формирует свой токен (например, строка `"voter1"`). 
			- : *Токен должен получаться от Аутентификатора, но адекватного аутентификатора (внешняя от голосования сущность) я не получу, его нужно будет формировать с нуля*
		- Вычисляется хэш токена: `H(token)`.
		- Токен заслепляется случайным значением и отправляется регистратору.
		- Регистратор подписывает слепой токен и возвращает слепую подпись.
		- Избиратель разлепляет подпись — получает слепую подпись на свой токен
		- Регистратор сохраняет факт регистрации и запрещает повторную регистрацию.
			- : *Если человек не завершил голосование, токен истекает через некоторое время, после чего человеку нужно будет производить перерегистрацию*
    
	2. Голосование
		- Избиратель кодирует свой выбор как вектор в виде байтового числа: например, кандидат 1 — это `2^(32 * 1)`, кандидат 2 — `2^(32 * 2)`, и т.д.
		- Голос шифруется с помощью системы Пайля для обеспечения гомоморфного шифрования: `Enc(vote)`.
		- Создаётся ZKP, что голос допустим (содержится в пределах генерации `2^(32 * 1..k)`)
		- Избиратель отправляет Счетчику:
		    - `Enc(vote)` — зашифрованный голос.
		    - `signature` — подпись регистратора на своём токене.
		    - `ZKP` — доказательство корректности.
		    - `voter_token` — для проверки подписи.
		- Счётчик:
		    - Проверяет подпись токена.
		    - Проверяет ZKP корректности.
		    - Если этот токен уже использовался ранее, предыдущий голос аннулируется.
		    - Добавляет голос в корзину.
		    - Добавляет голос в дерево хэшей и в реестр (дерево хэшей связывает все бюллетени вместе)
    
	3. Проверка голосоа
		- Голосующий может самостоятельно вычислить дерево хэшей и сверить его значение с корнем дерева
		- А хэш своего голоса он может обнаружить в самом реестре, на основе которого вычисляется дерево
    
	4. Подсчёт голосов
		- Все зашифрованные голоса перемножаются (гомоморфно).
		- Счётчик расшифровывает сумму.
		- Поскольку каждый кандидат закодирован в разные разряды (по 32 бита), результат можно разложить по битам и извлечь количество голосов за каждого кандидата.
			- `1000.0100.1100` -> `{1: 1, 2: 2, 3: 3}`


## Гомоморфное шифрование

Формирование параметров
+ Пусть p и q — большие простые числа
+ Вычисляется n = `p*q`
+ Выбирается такое g , что: $$НОД(L(g^{\lambda} \mod n^2), n) = 1$$
	+ ($\lambda = НОК(p-1, q-1)$), $L(x) = \frac{x-1}{n}$
+ Итого
	+ Публичный ключ (n, g)
	+ Приватный ключ (p, q) или вся $\lambda$

Шифрование
+ Есть некоторое сообщение m
+ Для него выбирается случайное r такое, что $НОД(n, r) = 1$
+ Зашифрованное сообщение: $c = g^m * r^n \mod n^2$

Расшифрование
+ $m = L(c^\lambda \mod n^2)*(L(g^\lambda \mod n^2))^{-1} \mod n$

Получение сложения
+ Через перемножение по модулю
	+ $encc = encc * enc_vote \mod n^2$ эквивалентно dec1+dec2

### В контексте протокола
+ Генерация параметров ($n, \lambda$)


## Слепые подписи
+ Есть открытый ключ (по RSA - $(e, n)$)
+ Есть сообщение $m$, которое требуется подписать.


1. $m$ "ослепляется" путем использования дополнительного случайного значения $r$ ($НОД(r, n) = 1$): $$m' = m*r^e \mod n$$
2. Подписывающая сторона подписывает сообщение $m'$: $$sign = (m')^d mod n$$
3. Отправитель "снимает ослепление": $$sign_{unblinded} = s*r^{-1} \mod n$$


## ZKP
+ Механика - ZKP OR доказательство принадлежности множеству
	+ Задача
		+ Доказать, что зашифрованное сообщение $m$ - является вариацией сообщений из конечного множества этих самых сообщений
	+ Причины выбора
		+ Количество сообщений ограничено, и есть их точный формат
	+ Механика
		+ Генерация коммитментов
			+ Для всех сообещнений производится гомоморфное шифрование для генерации доказательств (фиктивных): $$u_i = \frac{c}{g^{m_i}} \mod n^2$$
				+ Для сообщения, соответствующего передаваемому, шифрование происходит по другой формуле (правильное доказательство): $$u_i = \frac{c}{g^{m_i}} \frac{g^m*r^n}{g^m} \mod n^2$$
			+ Затем эти значения используются для вычисления коммитмента для всех сообщений вместе
				+ Коммитменты для фиктивных шифровок: $$a_i = \frac{z_i^{n}}{u_i^{e_i}} \mod n^2$$
				+ Коммитмент для шифровки правильного сообщения: $$a_i = \omega^{n} \mod n^2 $$
					+ e и z выбираются не сразу, а делаются немного позже, уже после выставления вызова
		+ Выставление челенджа
			+ Есть интерактивная и неинтерактивная схема. Для ускорения взаимодействия будет неинтерактивная форма - предполагает использование схемы Fiat-Shamir
				+ Задача схемы заполнить оставшиеся e и z для правильного сообщения
			+ От всех сформированных доказательств вместе формируется хэш в определенном виде: $$chal = H(a_1...a_i) \mod 2^B $$
			+ А затем полагается, что $$e_{true} = chal - sum(e...)$$
				+ Сумма всех имеющихся e должна быть равна полученному значению chal
			+ Получив e, вычисляют z: $$z_{true} = \omega*r^{e_{true}} \mod n$$
			+ Итого результатом становится: eVec, zVec, aVec. И из них не получится явно определить, какой по индексу компонент соответствует истинному сообщению

		+ Проверка
			1. `chal == sum(eVec)`
			2. $z_i^n == a_i * u_i^{e_i} \mod n^2$
				+ $u_i$ возможно вычислить, т.к. для этого есть все параметры
					+ Вычисляется как $$u_i = \frac{c}{g^{m_i}} \mod n^2$$
				+ И какой-то невообразимой магией $z_i$ должны совпасть






### Обновление 1
+ Bulletproofs не работают с основной схемой Пайе
	+ Bulletproofs основано на ECDSA
	+ Пайе работает на арифметике модулей
	+ Для ZKP нужно, чтобы математика могла быть синхронизирована друг между другом
+ EC-ElGamal как вариант гомоморфного аддитивного шифрования
	+ Синхронизируем с Bulletproofs
	+ Нельзя вытащить истинное значение полученной суммы
		+ Но можно использовать для суммарных подписей
### Обновление 2
+ Изменен формат бюллетеня
	+ Прошлый: `100000.100000.10000` на 3 опции в бюллетене
	+ Новый: `votes: {1: Enc(vote1),2: Enc(vote2),3: Enc(vote3)]`
		+ В vote валяются 0 и 1
		+ r параметры для криптосистемы Пайе выбираются каждый раз случайно для каждого обрабатываемого голоса (всего их генерируется `i`)
### Обновление 3
+ Формат Обновления 2 перестраивается
	+ Вместо 0 и 1 используются два простых числа
+ Получена проблема
	+ Нельяз обратно получить разложение на голоса за опции



### Обновление 4
+ Еще одно обновление формата из Обновления 2
	+ Вместо 0 и 1 использовать 1 и очень больше число формата `1_000_000`
	+ `{votes: {1: Enc(vote1), 2: Enc(vote2), 3: Enc(vote3)}}, vote: {1, 1_000_000_000}`
	+ Большое число должно быть заведомо больше, чем маленькое
	+ По итогу в сумме скопится вот это: `127830000017237` (нули разграничивают итоговые суммы)
 
### Обновление 5 (05.13)
+ Я наконец-таки смог создать схему проверки формата сообщения так, чтобы полноценно понять, где именно стоит единица не было возможно (формат сообщения из Обнолвения 2)
	+ Схема:
		+ Сумма всех голосов + Сумма всех попарных сложений голосов (питоновские комбинации). В сумме эти значения дают len(options), и таким образом гарантированно проверяют, что: 
			+ везде стоят либо 0, либо 1
			+ 1 стоит в одном месте
		+ Проблема формата: использование только 0 и 1 в процессе шифрования
			+ Возможно, просто претензия, но мне бы хотелось, чтобы само сообщение было одним-единственным в бинарном формате как из Обнолвения 1. Таким образом оно получается достаточно большим


### Обновление 6 (05.14)
+  Я нашел какую-то свежую статью с описанием нового метода управления ZKP в схеме Пайе.
	+ До сих пор не понимаю, что именно там происходит
	+ Это док-во позволяет мне перейти к формату сообщения из Обновления 1
+ ЧатГПТ по итогу дал мне какой-то очередной код, который вроде бы заработал
	+ Но дипсик заругался на процесс доказательства, возможно, там снова всё поплыло


### Обновление 7
+ По итогу найден рабочий вариант ZKP, который работает на основе списка вариантов. 
+ Предположительно, он нигде не использует в пункте verify исходное сообщение или значение r
	+ А значит, реализована полноценная схема доказательств нулевого доверия для всей схемы
+ 

