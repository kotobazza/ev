#include <gtest/gtest.h>
#include <vector>

#include "bigint.hpp"
#include "blind_signature.hpp"
#include "merklie_tree.hpp"
#include "pailier.hpp"
#include "zkp.hpp"

TEST(MultiprecisionArithmetic, IsBigIntClassWorks) {
    BigInt a = BigInt::fromString("111");
    EXPECT_EQ(a.toString(), "111");
}

TEST(MultiprecisionArithmetic, SimpleMiltiprecisionOperations) {
    BigInt a = BigInt::fromString("123456789012345678901234567890");
    BigInt b = BigInt::fromString("98765432109876543210");

    BigInt sum = a + b;
    BigInt diff = a - b;
    BigInt prod = a * b;
    BigInt quot = a / b;
    BigInt mod = a % b;

    EXPECT_EQ(sum.toString(), "123456789111111111011111111100");
    EXPECT_EQ(diff.toString(), "123456788913580246791358024680");
    EXPECT_EQ(prod.toString(), "12193263113702179522496570642237463801111263526900");
    EXPECT_EQ(quot.toString(), "1249999988");
    EXPECT_EQ(mod.toString(), "60185185207253086410");
}

TEST(PailierCryptography, SimpleUsecase) {
    BigInt p = BigInt::fromString("838382000974237847921957342377847823774311");
    BigInt q = BigInt::fromString("113011");

    auto [n, lambda_val, g] = generate_keys(p, q);

    std::vector<BigInt> votes{
        BigInt(2).pow(BigInt(30 * 1)), BigInt(2).pow(BigInt(30 * 1)), BigInt(2).pow(BigInt(30 * 1)),
        BigInt(2).pow(BigInt(30 * 1)), BigInt(2).pow(BigInt(30 * 1)),
    };

    std::vector<BigInt> encrypted_votes{};

    for (auto m : votes) {
        encrypted_votes.push_back(encrypt(m, BigInt(113), g, n));
    }

    BigInt encc{1};
    BigInt t{0};
    BigInt nn = n * n;

    for (auto i : encrypted_votes) {
        encc = (encc * i) % nn;
    }

    BigInt decsum = decrypt(encc, g, lambda_val, n);

    EXPECT_EQ(decsum.toString(), "5368709120");
}

TEST(PailierCryptography, HardLoad) {
    BigInt p = BigInt::fromString(
        "16404039174607693836360866480585614484544715780109420999587841911243314805066566626825650726886035765629970390"
        "89549681643050556549635257358690795777209850042468604069376784877781254003881410574446450853154325269463221049"
        "72494219200259177998517848835296770228674922695940834164143133401844103862534975584134053728686639397514762467"
        "32526677910766901702597914138830472395078921453562041777548374278654042973619250257136324320032842868953709957"
        "50844760980408776681372215036107346394928561229511548021683235453579706370411682264891424122924645293826133434"
        "7254820854775661531314072850103643102893024731790022431913878152973");
    BigInt q = BigInt::fromString(
        "23219647663524783783061952253556607743994047212392754088058700334758166821038715748297093329096091346687489206"
        "95324558663385920747230458501903508583147162181811408006545125413126853731651034318627210953261740426151770560"
        "76238745310453632149821843456762026205270743082992379696423750382725025494340716199685885921910799273608419681"
        "77484098371092248391541096285306112533514081769996159382745839407298935713369226168221834895191608536626380517"
        "35977008912939366203350474415993611416870288265177308685927035403003390426076167871372164098999884567620311168"
        "9059473305477120308757035114933199394449803026640152763363652056511");

    auto [n, lambda_val, g] = generate_keys(p, q);

    std::vector<BigInt> votes{
        BigInt(2).pow(BigInt(30 * 1)), BigInt(2).pow(BigInt(30 * 1)), BigInt(2).pow(BigInt(30 * 1)),
        BigInt(2).pow(BigInt(30 * 1)), BigInt(2).pow(BigInt(30 * 1)),
    };

    std::vector<BigInt> encrypted_votes{};

    for (auto m : votes) {
        encrypted_votes.push_back(encrypt(m, BigInt(113), g, n));
    }

    BigInt encc{1};
    BigInt t{0};
    BigInt nn = n * n;

    for (auto i : encrypted_votes) {
        encc = (encc * i) % nn;
    }

    BigInt decsum = decrypt(encc, g, lambda_val, n);

    EXPECT_EQ(decsum.toString(), "5368709120");
}

TEST(BlindSignature, SimpleTest) {
    try {
        // std::cout << "üîπ –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫–ª—é—á–µ–π RSA..." << std::endl;
        RSAKeyPair rsa;

        std::string message = "Hello, Blind Signature!";
        // std::cout << "–°–æ–æ–±—â–µ–Ω–∏–µ: '" << message << "'" << std::endl;

        // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ BigInt
        BigInt m = BlindSignature::messageToBigInt(message);

        // std::cout << "\nüîπ –û—Å–ª–µ–ø–ª–µ–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è..." << std::endl;
        auto [m_blinded, r] = BlindSignature::blind(m, rsa.publicKey.e, rsa.publicKey.n);

        // std::cout << "\nüîπ –ü–æ–¥–ø–∏—Å—å –æ—Å–ª–µ–ø–ª—ë–Ω–Ω–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è..." << std::endl;
        BigInt s_blinded = BlindSignature::signBlinded(m_blinded, rsa.privateKey.d, rsa.publicKey.n);

        // std::cout << "\nüîπ –°–Ω—è—Ç–∏–µ –æ—Å–ª–µ–ø–ª–µ–Ω–∏—è..." << std::endl;
        BigInt signature = BlindSignature::unblind(s_blinded, r, rsa.publicKey.n);

        // std::cout << "–ü–æ–ª—É—á–µ–Ω–Ω–∞—è –ø–æ–¥–ø–∏—Å—å: " << signature.toString() << std::endl;

        // std::cout << "\nüîπ –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–ø–∏—Å–∏..." << std::endl;
        [[maybe_unused]] bool is_valid = BlindSignature::verify(m, signature, rsa.publicKey.e, rsa.publicKey.n);
        // std::cout << "–ü–æ–¥–ø–∏—Å—å " << (is_valid ? "–≤–µ—Ä–Ω–∞" : "–Ω–µ–≤–µ—Ä–Ω–∞") << "!" << std::endl;

    } catch (const std::exception& e) {
        std::cerr << "–û—à–∏–±–∫–∞: " << e.what() << std::endl;
    }
}

TEST(ZKP, SimpleTest2) {
    try {
        // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫–ª—é—á–µ–π
        BigInt p = BigInt::fromString("838382000974237847921957342377847823774311");
        BigInt q = BigInt::fromString("113011");
        BigInt n = p * q;
        BigInt lambdaVal = lcm(p - BigInt(1), q - BigInt(1));
        BigInt g = n + BigInt(1);

        // –í–∞—Ä–∏–∞–Ω—Ç—ã –≥–æ–ª–æ—Å–æ–≤ (–¥–æ–ª–∂–Ω—ã –±—ã—Ç—å —É–Ω–∏–∫–∞–ª—å–Ω—ã–º–∏ –∏ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –±–æ–ª—å—à–∏–º–∏)
        std::vector<BigInt> voteVariants;
        for (int i = 0; i < 4; ++i) {
            voteVariants.push_back(BigInt(2).pow(BigInt(30 * i)));
        }

        // –¢–µ—Å—Ç–æ–≤—ã–µ –≥–æ–ª–æ—Å–∞ (–¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –∏–∑ voteVariants)
        std::vector<BigInt> votes;
        for (int i = 0; i < 5; ++i) {
            votes.push_back(BigInt(2).pow(BigInt(30 * 1)));
        }

        // –ü—Ä–æ–≤–µ—Ä–∫–∞, —á—Ç–æ –≤—Å–µ –≥–æ–ª–æ—Å–∞ –∏–∑ –¥–æ–ø—É—Å—Ç–∏–º—ã—Ö –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤
        /*
        for (const auto& vote : votes) {
            if (std::find(voteVariants.begin(), voteVariants.end(), vote) == voteVariants.end()) {
                throw std::runtime_error("–ì–æ–ª–æ—Å –Ω–µ –≤—Ö–æ–¥–∏—Ç –≤ –¥–æ–ø—É—Å—Ç–∏–º—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã");
            }
        }
        */

        // –ü—Ä–æ—Ü–µ—Å—Å –≥–æ–ª–æ—Å–æ–≤–∞–Ω–∏—è —Å –¥–æ–∫–∞–∑–∞—Ç–µ–ª—å—Å—Ç–≤–∞–º–∏
        std::vector<BigInt> encryptedVotes;
        std::vector<CorrectMessageProof> proofs;

        for (const auto& m : votes) {
            // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –¥–æ–∫–∞–∑–∞—Ç–µ–ª—å—Å—Ç–≤–∞
            CorrectMessageProof proof = CorrectMessageProof::prove(n, voteVariants, m);
            proofs.push_back(proof);

            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ–∫–∞–∑–∞—Ç–µ–ª—å—Å—Ç–≤–∞ (—ç—Ç–æ –±—É–¥–µ—Ç –¥–µ–ª–∞—Ç—å –ø–æ–ª—É—á–∞—Ç–µ–ª—å)
            if (!proof.verify()) {
                throw std::runtime_error("–î–æ–∫–∞–∑–∞—Ç–µ–ª—å—Å—Ç–≤–æ –Ω–µ –ø—Ä–æ—à–ª–æ –ø—Ä–æ–≤–µ—Ä–∫—É");
            }

            // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–π –≥–æ–ª–æ—Å
            encryptedVotes.push_back(proof.getCiphertext());

            std::cout << "–ó–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–π –≥–æ–ª–æ—Å: " << proof.getCiphertext().toString() << std::endl;
        }

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—Å–µ—Ö –±—é–ª–ª–µ—Ç–µ–Ω–µ–π –ø–µ—Ä–µ–¥ –ø–æ–¥—Å—á–µ—Ç–æ–º
        std::cout << "–ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—Å–µ—Ö –±—é–ª–ª–µ—Ç–µ–Ω–µ–π –ø–µ—Ä–µ–¥ –ø–æ–¥—Å—á–µ—Ç–æ–º:" << std::endl;
        for (size_t i = 0; i < proofs.size(); ++i) {
            if (!proofs[i].verify()) {
                std::cout << "–ë—é–ª–ª–µ—Ç–µ–Ω—å " << i << " –Ω–µ –ø—Ä–æ—à–µ–ª –ø—Ä–æ–≤–µ—Ä–∫—É!" << std::endl;
            } else {
                std::cout << "–ë—é–ª–ª–µ—Ç–µ–Ω—å " << i << " –∫–æ—Ä—Ä–µ–∫—Ç–µ–Ω" << std::endl;
            }
        }

        // –ü–æ–¥—Å—á–µ—Ç –≥–æ–ª–æ—Å–æ–≤ (–≥–æ–º–æ–º–æ—Ä—Ñ–Ω–æ–µ —Å–ª–æ–∂–µ–Ω–∏–µ)
        BigInt encryptedSum(1);
        for (const auto& vote : encryptedVotes) {
            encryptedSum = (encryptedSum * vote) % (n * n);
        }

        // –†–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–∞ —Å—É–º–º—ã
        BigInt numerator = ((encryptedSum.modExp(lambdaVal, n * n) - BigInt(1)) / n) % n;
        BigInt denominator = ((g.modExp(lambdaVal, n * n) - BigInt(1)) / n) % n;
        BigInt decryptedSum = (numerator * denominator.modInverse(n)) % n;

        std::cout << "–ò—Ç–æ–≥–æ–≤—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç: " << decryptedSum.toString() << std::endl;

    } catch (const std::exception& e) {
        std::cerr << "–û—à–∏–±–∫–∞: " << e.what() << std::endl;
    }
}

TEST(MerklieTree, SimpleUsage) {
    MerkleTree a;
    a.addLeaf("1234");
    a.addLeaf("12345");
    a.addLeaf("12346");
    a.addLeaf("12347");
    a.addLeaf("12348");
    a.addLeaf("12349");

    EXPECT_EQ(a.getRoot(),
              "5816f1c61fa426728ee36f4275256c45855f1e5df157271d1411693a8ed47c92ab52a3ac8a4e9df6acccaa04405c4ff44710846d"
              "7ea0fe30ff364a42effa854d");

    std::string input = "12349";

    EVP_MD_CTX* mdctx = EVP_MD_CTX_new();
    const EVP_MD* md = EVP_sha512();
    unsigned char hash[SHA512_DIGEST_LENGTH];
    unsigned int hash_len;

    EVP_DigestInit_ex(mdctx, md, nullptr);
    EVP_DigestUpdate(mdctx, input.c_str(), input.size());
    EVP_DigestFinal_ex(mdctx, hash, &hash_len);
    EVP_MD_CTX_free(mdctx);

    std::stringstream ss;
    for (int i = 0; i < SHA512_DIGEST_LENGTH; i++) {
        ss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(hash[i]);
    }

    std::string hex_ = ss.str();

    auto b = a.getProof(hex_);

    EXPECT_EQ(b.size(), static_cast<size_t>(2));
    EXPECT_EQ(b[0].first,
              "2de2b0c9e6e6765d8000d0d6532759789eece2c60563a8ce6a0da857d0337b1c754e5606c5dfb73c37697110db0da1123505310b"
              "4e9938976c2010b81ef81a1e");
    EXPECT_EQ(b[1].first,
              "8f54cde82fc63dd8f19047de1e8ba5319df1d45164f5506136b5a25838603a4a950c5a813851c1cf4a8dc2351f3c53a37497ff52"
              "889c050009847507511c6d9a");
    EXPECT_EQ(b[0].second, false);
    EXPECT_EQ(b[1].second, false);

    a.removeLeaf(hex_);

    EXPECT_EQ(a.getRoot(),
              "2a7b999456d176eed8f89997b665b602f193848dd616163f595ff054beda97d3fdd2346f123dc33e8a0c377e1b35bad9daa2c0ee"
              "9105fc764c3d4f0ec89cc2b3");

    std::ofstream outFile("merkle_tree.json");

    if (outFile.is_open()) {
        a.serialize(outFile);
        outFile.close();
    }
}

TEST(ZKP, AdditionalProves) {
    BigInt n = BigInt::fromString(
        "38089600989304856086482318810723385896398240399689251567738501021439968074673025185637718386773707987978862422"
        "67677600150494432732161976784259269558511239516800459104383252101833414465255197326164953899416567749993382091"
        "21700543549400831719887789241885970910418134252817104741423771936821996129601753666411089803077304575969167078"
        "59608347774056660632112757816357021810663233532786700823093142131312966893811779468000268206241471259761003324"
        "37844128909320789953256452446064353820242912507286596714131455126286864625152105491631713049552659496031396319"
        "64298586781973910155230496914147236961035678634158527659716556090467815377731835032074071006141116987097028583"
        "49482192882021430063343748979457570607514318162730455178913056329323787430103514045390151591166676401775995241"
        "24986880481015763601429120152938982063824363613353922513313635531188441310899122538291679559678457087915735890"
        "35275802365027223503811223794495306140657344210614574188880970705676011397756033435333448815707274737506211413"
        "06666639412397985123660455515065530656649359014682756795574228730414835770190143430298742053945803172589064416"
        "48785690054977035147489001541460437192841504074323578110000830029934258704211681936207762622919306759388206295"
        "65305882369105698657203");
    BigInt r = BigInt::fromString(
        "20812197462198414887759978081142355862194537827970386287838801667259802112864771980573048792495234984990481325"
        "26170502216792658815469893362374220923051607980273911526736672650455447027791705919417000966737384669713146318"
        "34313933228274955558730115419389246487021252906973443212558433242840339752838201139530735690707477842451638973"
        "88557958754324485592211304365504257351701846319261568983460306639140338036141286653316913290433340249135871783"
        "81065861525893699434717980370447426921761121082743096341815533787872944189116670899363018203060714671722391934"
        "71349608727258450665353202509336179061146032958580275106784250668360905575036123968526029252019198397842580200"
        "27058085734604375937744215219096715257318415061836297047631345571966375035567410616862966271379137410734158753"
        "07051697779424864194506120008908132419376222621028299689123785772706081105808568444245672073097993474214750344"
        "61375564840865423203270407825779942043282552542251126279856896186097087742477318737198396472709646537123475115"
        "29588634260946541562929302125519973635958928003299210283895884457961839739301909897393837207187265996825389880"
        "30067818640873854124669846434189151292663505460152171142136229589070721042085752328865526620164654106102915099"
        "6499711101143122250902");

    std::vector<BigInt> ziVec{
        BigInt::fromString(
            "1605836870155397149934180231669286179150900118438690060496849514857840903072584575327020846149034806903"
            "4338367038470622974089477618785997404132687962544029966551624948730032033580671370497682702064655056926"
            "3867983097073648873545938068014901810825569524097851087981354750788518950400370049165954919898732875591"
            "3715641390353167108355861840689851229212042266343993404735845246904539063142874210713723152904128979830"
            "9344160119014199831984206604805360431785304102870355207633213485527637830834521107284029445896153033279"
            "0583962631086861768618433038786469315020313512846677040990904785007991434272373608758303986128547444088"
            "9205676089720717974244876227947058764992567634724479003528820440675118964566688146906450698016473629756"
            "9997773104616476314715922122549299742541591936648242077401808868294691039781087166943665984009350060614"
            "3563736038475883727599592121241442125234308690205956891618987531344978768154735288029469307473868676870"
            "5335763403316942183586297783349682434016769844128043859915678138194426760700278405541358338397102299138"
            "9812040799865009905596235093267489384897006646080211100204178856636035564163916796978515537393238543362"
            "7824980037513018000975779274646278383107675226724208962521593601078714107400393595082028079887512193"),
        BigInt::fromString(
            "8881626845220167975138648607635949685519562207675836762231459026802650439087919351970330220467331844961"
            "0481070064323104605009225490965655094534125141073748444721026646329158278523085355771748387162975034051"
            "6814920319524912368618891819813412102582576441800389440878867419464949929110724574403390247772504342507"
            "8640586012865479020305091843280418613489540205370372341147479823321126637154419684082394820236520990649"
            "5915606225141543957304127511925775691360828978119815140256727757687875454707809965227040393496942709381"
            "2687756262042155206989864349506039524204155740164112071675834225069157024400920199837502910265950809233"
            "9810213362405383262752467187900167227787132776799393729526228466217601658707823186090495653030546806455"
            "7498790276603459803511862668411421204152541770414049258367903066242401050770948581046665148256630458481"
            "6865523108512472095199132332465186439943548847874411748124336800301079204537395058675131302043416849093"
            "3202191244159885589121197465063087101574261109659300065251000108256593197721481455444786169383543708698"
            "0050413959827948643900873795356593881494728430486371525318269573752128617997192302329037865088597395473"
            "425899461812817523098705091043332648108267036548899629084589733436066810516908306216114090754763348"),
    };

    std::vector<BigInt> eiVec{
        BigInt::fromString("80202988921795916388281716478631576779076299504468531256800339585132691958970"),
        BigInt::fromString("7324626410221592119099880977314371662453875078409971785479274873350811520326")};

    BigInt w = BigInt::fromString(
        "20144678041720788686830818145083245540841754381332201873850324822102936531636151077302211602574929492882573952"
        "40126358018253013378141218522910109400983082544601377662673962583917453169200350781074391375044213847566504940"
        "14759418986634088064324876505404493059935725387599910009034888052693759935508232671391655394543843709579945425"
        "94195767907053619614587904769852006674506482177948566412104435136270283133598928712462612629633103282057798394"
        "68431087772580999027463338741082629751174196358567802796845241776982029612105060691319550356624360119842261028"
        "80029635908410985973938195541674715615299544168564824382099481556212946855795514286658570928098702038737055024"
        "18040910392131411382141763344885501833174882838426944745422663051108552183038116150452221135729460394878349247"
        "12114204601448775947762834543271503093789785430175207074701356634608502370266525940727527624353646478805881912"
        "31514100315941598335113341195810585577286023099149048526186973470691108193428974260659830774590238978221311555"
        "43058571728129925121601042310221407750578049707323468004198570352878274505127503721739312339009802988414724902"
        "92700726262322706743211468923189254553824368978852702831271459090536020602567557144056240696448809269748802732"
        "84941703650319756346367");

    std::vector<BigInt> msgVariants;
    for (size_t i = 0; i < 3; i++) {
        msgVariants.push_back(BigInt(2).pow(BigInt(30 * i)));
    }

    BigInt msgToEnc = BigInt(1);
    BigInt encryptedMessage = BigInt::fromString(
        "90437538421799689831906903706038182451494279872936917249780067350704779142488863502972969558533870988734456870"
        "00951675124341918619127465394519782810475748262561024660751935731030750591783789513535156678197256001780233361"
        "72534529444963300680456788159179645377501698849110878155058745782639480270362571112575340302387533189255628103"
        "52848456763066260476556962225224416516803480850720245142918593280636366479170351982052014353014465505517494920"
        "72792603210737424802705923464515486358042702874942449801117965766999322005281770536413199251463024925087103245"
        "97381478175071352285051315710937180504694324926098446076085991265767451682270434601071030546886370793077445425"
        "86834482084204127622415183566106282541650317298513791664976740337380468539543491008967225032202350255007473997"
        "47241409392516811572331850590821426801753074193380716266004656336922600836858524324533722449777103653354640274"
        "26103262751853416782274288382867587402905913345112959827601653461230748844373571472269800686350950619659187591"
        "90855874058273815629476630275092830801509649526821589977745186615766992190690555384543716166563354524320316850"
        "87676779950584709807921749967868714645722973891578678999371973947277389218760201137681884748581888835961361408"
        "01635291178359196566291857658365949935707042209558949930392765465169608951913411479272041928336300400331642014"
        "52599306629821184602360016535108723483557849609735864043819863949606559864151741025708378772134622413325276470"
        "38271873475722310495192034719495283357054387718529396619612304874478739647881229258336551723028554803931134563"
        "62647297284906947219621096333786465030546421707487807303772666893886933387520535545745028379663450866909798902"
        "83923022708901164331903027428412407183233039528271025053388738437179790508200821995879140949453171049517170449"
        "85100507362039714728357658715877702214285344873044778676425833073738815836634489116110652449884886862579396697"
        "17684391016194921444681346170778223638527190276263977720870645998595197916572580826347282675176017582281260070"
        "15033700636180552179483076771921101026197986172088800534414123137151984373085430326787858605484441011552707574"
        "39579147022859480836336581077003040921944020286153935515307380502338672847836722564209389713808806067945739630"
        "63449487361109201619026694694602595358396263867346801705765400746708558064384727354254925744433729740527111512"
        "61038662475024136991758220363491788242851872449671733022919277953358610277762441526222485313967479434858334183"
        "609368268557707911735099170447454537770933126");

    CorrectMessageProof proof2(r, ziVec, eiVec, w, encryptedMessage, 0, msgVariants, n);

    std::cout << "proof.verify: " << proof2.verify();
    std::cout << "\n";
    std::cout << "\n";

    auto aVec = proof2.getA();
    auto zVec = proof2.getZ();
    auto eVec = proof2.getE();

    for (const auto& i : aVec) {
        std::cout << i.toString() << "\n";
    }
    std::cout << "\n";
    std::cout << "\n";

    for (const auto& i : eVec) {
        std::cout << i.toString() << "\n";
    }
    std::cout << "\n";
    std::cout << "\n";

    for (const auto& i : zVec) {
        std::cout << i.toString() << "\n";
    }
    std::cout << "\n";
    std::cout << "\n";

    EXPECT_EQ(1, 1);
}

int main(int argc, char** argv) {
    testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}