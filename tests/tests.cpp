#include <gtest/gtest.h>
#include <vector>

#include "bignum.hpp"
#include "blind_signature.hpp"
#include "merklie_tree.hpp"
#include "pailier.hpp"
#include "zkp.hpp"

TEST(MultiprecisionArithmetic, IsBigNumClassWorks) {
    BigNum a("111");
    EXPECT_EQ(a.toString(), "111");
}

TEST(MultiprecisionArithmetic, SimpleMiltiprecisionOperations) {
    BigNum a("123456789012345678901234567890");
    BigNum b("98765432109876543210");

    BigNum sum = a + b;
    BigNum diff = a - b;
    BigNum prod = a * b;
    BigNum quot = a / b;
    BigNum mod = a % b;

    EXPECT_EQ(sum.toString(), "123456789111111111011111111100");
    EXPECT_EQ(diff.toString(), "123456788913580246791358024680");
    EXPECT_EQ(prod.toString(), "12193263113702179522496570642237463801111263526900");
    EXPECT_EQ(quot.toString(), "1249999988");
    EXPECT_EQ(mod.toString(), "60185185207253086410");
}

TEST(PailierCryptography, SimpleUsecase) {
    BigNum p("838382000974237847921957342377847823774311");
    BigNum q("113011");

    auto [n, lambda_val, g] = generate_keys(p, q);

    std::vector<BigNum> votes{
        BigNum(2).pow(BigNum(30 * 1)), BigNum(2).pow(BigNum(30 * 1)), BigNum(2).pow(BigNum(30 * 1)),
        BigNum(2).pow(BigNum(30 * 1)), BigNum(2).pow(BigNum(30 * 1)),
    };

    std::vector<BigNum> encrypted_votes{};

    for (auto m : votes) {
        encrypted_votes.push_back(encrypt(m, BigNum(113), g, n));
    }

    BigNum encc{1};
    BigNum t{0};
    BigNum nn = n * n;

    for (auto i : encrypted_votes) {
        encc = (encc * i) % nn;
    }

    BigNum decsum = decrypt(encc, g, lambda_val, n);

    EXPECT_EQ(decsum.toString(), "5368709120");
}

TEST(PailierCryptography, HardLoad) {
    BigNum p(
        "16404039174607693836360866480585614484544715780109420999587841911243314805066566626825650726886035765629970390"
        "89549681643050556549635257358690795777209850042468604069376784877781254003881410574446450853154325269463221049"
        "72494219200259177998517848835296770228674922695940834164143133401844103862534975584134053728686639397514762467"
        "32526677910766901702597914138830472395078921453562041777548374278654042973619250257136324320032842868953709957"
        "50844760980408776681372215036107346394928561229511548021683235453579706370411682264891424122924645293826133434"
        "7254820854775661531314072850103643102893024731790022431913878152973");
    BigNum q(
        "23219647663524783783061952253556607743994047212392754088058700334758166821038715748297093329096091346687489206"
        "95324558663385920747230458501903508583147162181811408006545125413126853731651034318627210953261740426151770560"
        "76238745310453632149821843456762026205270743082992379696423750382725025494340716199685885921910799273608419681"
        "77484098371092248391541096285306112533514081769996159382745839407298935713369226168221834895191608536626380517"
        "35977008912939366203350474415993611416870288265177308685927035403003390426076167871372164098999884567620311168"
        "9059473305477120308757035114933199394449803026640152763363652056511");

    auto [n, lambda_val, g] = generate_keys(p, q);

    std::vector<BigNum> votes{
        BigNum(2).pow(BigNum(30 * 1)), BigNum(2).pow(BigNum(30 * 1)), BigNum(2).pow(BigNum(30 * 1)),
        BigNum(2).pow(BigNum(30 * 1)), BigNum(2).pow(BigNum(30 * 1)),
    };

    std::vector<BigNum> encrypted_votes{};

    for (auto m : votes) {
        encrypted_votes.push_back(encrypt(m, BigNum(113), g, n));
    }

    BigNum encc{1};
    BigNum t{0};
    BigNum nn = n * n;

    for (auto i : encrypted_votes) {
        encc = (encc * i) % nn;
    }

    BigNum decsum = decrypt(encc, g, lambda_val, n);

    EXPECT_EQ(decsum.toString(), "5368709120");
}

TEST(BlindSignature, SimpleTest) {
    try {
        // std::cout << "üîπ –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫–ª—é—á–µ–π RSA..." << std::endl;
        RSAKeyPair rsa;

        std::string message = "Hello, Blind Signature!";
        // std::cout << "–°–æ–æ–±—â–µ–Ω–∏–µ: '" << message << "'" << std::endl;

        // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ BigNum
        BigNum m = BlindSignature::messageToBigNum(message);

        // std::cout << "\nüîπ –û—Å–ª–µ–ø–ª–µ–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è..." << std::endl;
        auto [m_blinded, r] = BlindSignature::blind(m, rsa.publicKey.e, rsa.publicKey.n);

        // std::cout << "\nüîπ –ü–æ–¥–ø–∏—Å—å –æ—Å–ª–µ–ø–ª—ë–Ω–Ω–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è..." << std::endl;
        BigNum s_blinded = BlindSignature::signBlinded(m_blinded, rsa.privateKey.d, rsa.publicKey.n);

        // std::cout << "\nüîπ –°–Ω—è—Ç–∏–µ –æ—Å–ª–µ–ø–ª–µ–Ω–∏—è..." << std::endl;
        BigNum signature = BlindSignature::unblind(s_blinded, r, rsa.publicKey.n);

        // std::cout << "–ü–æ–ª—É—á–µ–Ω–Ω–∞—è –ø–æ–¥–ø–∏—Å—å: " << signature.toString() << std::endl;

        // std::cout << "\nüîπ –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–ø–∏—Å–∏..." << std::endl;
        [[maybe_unused]] bool is_valid = BlindSignature::verify(m, signature, rsa.publicKey.e, rsa.publicKey.n);
        // std::cout << "–ü–æ–¥–ø–∏—Å—å " << (is_valid ? "–≤–µ—Ä–Ω–∞" : "–Ω–µ–≤–µ—Ä–Ω–∞") << "!" << std::endl;

    } catch (const std::exception& e) {
        std::cerr << "–û—à–∏–±–∫–∞: " << e.what() << std::endl;
    }
}

TEST(ZKP, SimpleTest2) {
    try {
        // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫–ª—é—á–µ–π
        BigNum p("838382000974237847921957342377847823774311");
        BigNum q("113011");
        BigNum n = p * q;
        BigNum lambdaVal = lcm(p - BigNum(1), q - BigNum(1));
        BigNum g = n + BigNum(1);

        // –í–∞—Ä–∏–∞–Ω—Ç—ã –≥–æ–ª–æ—Å–æ–≤ (–¥–æ–ª–∂–Ω—ã –±—ã—Ç—å —É–Ω–∏–∫–∞–ª—å–Ω—ã–º–∏ –∏ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –±–æ–ª—å—à–∏–º–∏)
        std::vector<BigNum> voteVariants;
        for (int i = 0; i < 4; ++i) {
            voteVariants.push_back(BigNum(2).pow(BigNum(30 * i)));
        }

        // –¢–µ—Å—Ç–æ–≤—ã–µ –≥–æ–ª–æ—Å–∞ (–¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –∏–∑ voteVariants)
        std::vector<BigNum> votes;
        for (int i = 0; i < 5; ++i) {
            votes.push_back(BigNum(2).pow(BigNum(30 * 1)));
        }

        // –ü—Ä–æ–≤–µ—Ä–∫–∞, —á—Ç–æ –≤—Å–µ –≥–æ–ª–æ—Å–∞ –∏–∑ –¥–æ–ø—É—Å—Ç–∏–º—ã—Ö –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤
        /*
        for (const auto& vote : votes) {
            if (std::find(voteVariants.begin(), voteVariants.end(), vote) == voteVariants.end()) {
                throw std::runtime_error("–ì–æ–ª–æ—Å –Ω–µ –≤—Ö–æ–¥–∏—Ç –≤ –¥–æ–ø—É—Å—Ç–∏–º—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã");
            }
        }
        */

        // –ü—Ä–æ—Ü–µ—Å—Å –≥–æ–ª–æ—Å–æ–≤–∞–Ω–∏—è —Å –¥–æ–∫–∞–∑–∞—Ç–µ–ª—å—Å—Ç–≤–∞–º–∏
        std::vector<BigNum> encryptedVotes;
        std::vector<CorrectMessageProof> proofs;

        for (const auto& m : votes) {
            // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –¥–æ–∫–∞–∑–∞—Ç–µ–ª—å—Å—Ç–≤–∞
            CorrectMessageProof proof = CorrectMessageProof::prove(n, voteVariants, m);
            proofs.push_back(proof);

            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ–∫–∞–∑–∞—Ç–µ–ª—å—Å—Ç–≤–∞ (—ç—Ç–æ –±—É–¥–µ—Ç –¥–µ–ª–∞—Ç—å –ø–æ–ª—É—á–∞—Ç–µ–ª—å)
            if (!proof.verify()) {
                throw std::runtime_error("–î–æ–∫–∞–∑–∞—Ç–µ–ª—å—Å—Ç–≤–æ –Ω–µ –ø—Ä–æ—à–ª–æ –ø—Ä–æ–≤–µ—Ä–∫—É");
            }

            // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–π –≥–æ–ª–æ—Å
            encryptedVotes.push_back(proof.getCiphertext());

            std::cout << "–ó–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–π –≥–æ–ª–æ—Å: " << proof.getCiphertext().toString() << std::endl;
        }

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—Å–µ—Ö –±—é–ª–ª–µ—Ç–µ–Ω–µ–π –ø–µ—Ä–µ–¥ –ø–æ–¥—Å—á–µ—Ç–æ–º
        std::cout << "–ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—Å–µ—Ö –±—é–ª–ª–µ—Ç–µ–Ω–µ–π –ø–µ—Ä–µ–¥ –ø–æ–¥—Å—á–µ—Ç–æ–º:" << std::endl;
        for (size_t i = 0; i < proofs.size(); ++i) {
            if (!proofs[i].verify()) {
                std::cout << "–ë—é–ª–ª–µ—Ç–µ–Ω—å " << i << " –Ω–µ –ø—Ä–æ—à–µ–ª –ø—Ä–æ–≤–µ—Ä–∫—É!" << std::endl;
            } else {
                std::cout << "–ë—é–ª–ª–µ—Ç–µ–Ω—å " << i << " –∫–æ—Ä—Ä–µ–∫—Ç–µ–Ω" << std::endl;
            }
        }

        // –ü–æ–¥—Å—á–µ—Ç –≥–æ–ª–æ—Å–æ–≤ (–≥–æ–º–æ–º–æ—Ä—Ñ–Ω–æ–µ —Å–ª–æ–∂–µ–Ω–∏–µ)
        BigNum encryptedSum(1);
        for (const auto& vote : encryptedVotes) {
            encryptedSum = (encryptedSum * vote) % (n * n);
        }

        // –†–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–∞ —Å—É–º–º—ã
        BigNum numerator = ((encryptedSum.modExp(lambdaVal, n * n) - BigNum(1)) / n) % n;
        BigNum denominator = ((g.modExp(lambdaVal, n * n) - BigNum(1)) / n) % n;
        BigNum decryptedSum = (numerator * denominator.modInverse(n)) % n;

        std::cout << "–ò—Ç–æ–≥–æ–≤—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç: " << decryptedSum.toString() << std::endl;

    } catch (const std::exception& e) {
        std::cerr << "–û—à–∏–±–∫–∞: " << e.what() << std::endl;
    }
}

TEST(MerklieTree, SimpleUsage) {
    MerkleTree a;
    a.addLeaf("1234");
    a.addLeaf("12345");
    a.addLeaf("12346");
    a.addLeaf("12347");
    a.addLeaf("12348");
    a.addLeaf("12349");

    EXPECT_EQ(a.getRoot(),
              "5816f1c61fa426728ee36f4275256c45855f1e5df157271d1411693a8ed47c92ab52a3ac8a4e9df6acccaa04405c4ff44710846d"
              "7ea0fe30ff364a42effa854d");

    std::string input = "12349";

    EVP_MD_CTX* mdctx = EVP_MD_CTX_new();
    const EVP_MD* md = EVP_sha512();
    unsigned char hash[SHA512_DIGEST_LENGTH];
    unsigned int hash_len;

    EVP_DigestInit_ex(mdctx, md, nullptr);
    EVP_DigestUpdate(mdctx, input.c_str(), input.size());
    EVP_DigestFinal_ex(mdctx, hash, &hash_len);
    EVP_MD_CTX_free(mdctx);

    std::stringstream ss;
    for (int i = 0; i < SHA512_DIGEST_LENGTH; i++) {
        ss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(hash[i]);
    }

    std::string hex_ = ss.str();

    auto b = a.getProof(hex_);

    EXPECT_EQ(b.size(), static_cast<size_t>(2));
    EXPECT_EQ(b[0].first,
              "2de2b0c9e6e6765d8000d0d6532759789eece2c60563a8ce6a0da857d0337b1c754e5606c5dfb73c37697110db0da1123505310b"
              "4e9938976c2010b81ef81a1e");
    EXPECT_EQ(b[1].first,
              "8f54cde82fc63dd8f19047de1e8ba5319df1d45164f5506136b5a25838603a4a950c5a813851c1cf4a8dc2351f3c53a37497ff52"
              "889c050009847507511c6d9a");
    EXPECT_EQ(b[0].second, false);
    EXPECT_EQ(b[1].second, false);

    a.removeLeaf(hex_);

    EXPECT_EQ(a.getRoot(),
              "2a7b999456d176eed8f89997b665b602f193848dd616163f595ff054beda97d3fdd2346f123dc33e8a0c377e1b35bad9daa2c0ee"
              "9105fc764c3d4f0ec89cc2b3");

    std::ofstream outFile("merkle_tree.json");

    if (outFile.is_open()) {
        a.serialize(outFile);
        outFile.close();
    }
}

TEST(ZKP, AdditionalProves) {
    BigNum n(
        "38089600989304856086482318810723385896398240399689251567738501021439968074673025185637718386773707987978862422"
        "67677600150494432732161976784259269558511239516800459104383252101833414465255197326164953899416567749993382091"
        "21700543549400831719887789241885970910418134252817104741423771936821996129601753666411089803077304575969167078"
        "59608347774056660632112757816357021810663233532786700823093142131312966893811779468000268206241471259761003324"
        "37844128909320789953256452446064353820242912507286596714131455126286864625152105491631713049552659496031396319"
        "64298586781973910155230496914147236961035678634158527659716556090467815377731835032074071006141116987097028583"
        "49482192882021430063343748979457570607514318162730455178913056329323787430103514045390151591166676401775995241"
        "24986880481015763601429120152938982063824363613353922513313635531188441310899122538291679559678457087915735890"
        "35275802365027223503811223794495306140657344210614574188880970705676011397756033435333448815707274737506211413"
        "06666639412397985123660455515065530656649359014682756795574228730414835770190143430298742053945803172589064416"
        "48785690054977035147489001541460437192841504074323578110000830029934258704211681936207762622919306759388206295"
        "65305882369105698657203");
    BigNum r(
        "27010479149733140763780089778078086377107455209540279210023938064839401079769702920806308174401481929710619226"
        "15221515670988678377765713009446629884929737189128116295206104276690087025779176938737827172431586658645440013"
        "79974098750635452983900187262847438788177388808608346423496995931115835043478391043907267149730469949110655232"
        "46457025165956838746379479730695639121474841514489393669671680765156521572987412291235964038847181681555951329"
        "08153392422564737980966190409148732179353180948000092854502836274624989038625630448139746100252630765632133543"
        "14155590142390138246089558153672851112881817492434673353801989048512469359379816253975710205070583876677342378"
        "34162100178044576099455055055986326903226362038154324495509420325396125972645696129367685502786008217432222920"
        "48252637725987212273424735977055480724383419337760974631275060668912643912049973216530405740752636460866198402"
        "23121703410772151030183063135914999328906157230020353113401829594829997882025952628722012343247527138566638438"
        "74140067048412442887818185329965343931357288325837103154319390729798135220253601942035738671335750001629689894"
        "51790736661914511945716097312689169251398714297924602293667415920436419525066911253106375453240909671568600771"
        "62457869795875656072692");

    std::vector<BigNum> ziVec{
        BigNum("1949291589668980995051371505497109122608892889272046077261994511698515731220203452535800720703494456593"
               "5770892675939203852537702885292997883143810785390628753744158507782175000412031823065604205649613216391"
               "4186377710474152399320240847840471375521194947557419102207063250877744437230043283228227014725902974260"
               "5538108820692474177489988660376700495198306729583516723673087694338926659405486009249203187864404557301"
               "2482052078164727094390163946371391835846980271039895151032448451256848256159258293240918890556518285095"
               "1655629271910381254958545310518221773068014565185397419780881200251632212451948387592628956460576151814"
               "4273627474999157106713782746717309888549245358874234997603809169092390248925226213676023585677081400682"
               "6092322390415702151202440996938768363885714517307825740260137209886183852119023115915928003506992403180"
               "0751339846352420859843678122935123271538840477858267501460137156036059895413998155961446991387376318264"
               "0095059597134495555947657679046825493454137222421250472585376912754770699603447365226684066316885089455"
               "5641791162942039866413740990592155950882027256249633957389148759150994829283304256127773336588749614144"
               "3519242679585961075346540251646996851340002098552413256851210131447839648734185458910052645019389483"),
        BigNum("1900218238340085781405588096422787033403797322873482801532287917911235609371027590453731604491134624271"
               "7387459572999545583711152869656566689020363637786312239105192713288644266839987660380285678071688165885"
               "3575962468557421140739456635980630004793315273420284110979174339229118017120767017483341320137720318735"
               "5705517388602582775161078846709238403772855831357862358717202542243895380234081070641793684838832612660"
               "4004143955016691449062184716564677222534029139931672944328742823861717869513443243727389808898587957174"
               "9779724386696402247662857305432604780342010109942695838880864436686018089681227885838184914874597634834"
               "4746811796284723988102242662879057326993279910640306864881107114446796516864860639980085179043061621347"
               "5844104524932613957206472449541179805298605528923323550485285042465677361776264393127325046204794108875"
               "6905622522881715684352080781409957151248166969915795623360847628420312325641870503994677534804266176900"
               "6900344115142205589307679948916210031350343815095003600371229632459552936413246074579531997263300692191"
               "2452326654792283596302902993552624684376114904700961917387958911479867244997858317337879112010770151801"
               "4510861249611233026825456167397045187478446275050894250611393288264511606278478010106111122682943561"),
    };
    BigNum w(
        "25301684290700048352566015126751408600614514816736059237545216213060788103833477724469492176891904380615292306"
        "17684360867600107937112981287737043558106596674074986352186483219883073352754454098313675636888531677950532810"
        "38027004066982550217507684632753800195450706522916529795577536552256795835025037616258751170047507727155981565"
        "00905574064539527178040928130697313742667841440669721885973969392253829677368349735553167980097630543320104864"
        "06167149182950821250796786830274264989053014369243669504652125603167826682145952915429733180492839462409272093"
        "69475189312847884348259641847274070789143623735924952295163027683047490135146607847004694817386773171241599916"
        "61339464915116908569285027160074485674399054552719241965237704476086860959376123872649493605814123981502834317"
        "58040948816874132783558515326189313948403110042147407071405830870398486520381102582017239116765257249298101696"
        "60574202894505239431855429825400352028797899708417360427381087734486510791461606525391343392429379366445022340"
        "01395875413976719921799853508748851452277293312218014102639024411132993260575237875783900543240734509222965403"
        "03041502014244630837423861171800125562238411988311060621248589617323130157819132070058430900649980536420832672"
        "21862614365661412727393");

    std::vector<BigNum> msgVariants;
    for (size_t i = 0; i < 3; i++) {
        msgVariants.push_back(BigNum(2).pow(BigNum(30 * i)));
    }

    BigNum msgToEnc = BigNum(1);

    CorrectMessageProof proof(r, ziVec, w, n, msgVariants, msgToEnc);

    std::cout<<"proof.verify: "<<proof.verify();
    std::cout << "\n";
    std::cout << "\n";


    auto aVec = proof.getA();
    auto zVec = proof.getZ();
    auto eVec = proof.getE();

    for(const auto& i:aVec){
        std::cout<<i.toString()<<"\n";
    }
    std::cout << "\n";
    std::cout << "\n";

    for(const auto& i:eVec){
        std::cout<<i.toString()<<"\n";
    }
    std::cout << "\n";
    std::cout << "\n";

    for(const auto& i:zVec){
        std::cout<<i.toString()<<"\n";
    }
    std::cout << "\n";
    std::cout << "\n";



    EXPECT_EQ(1, 1);

}

int main(int argc, char** argv) {
    testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}